(4) 본인이 주력으로 사용하는 언어에서 설계적 결함 한 가지를 작성해주세요.

내가 현재 주력으로 사용하는 언어는 `Java(이하 자바)`로, 나의 첫 객체지향 프로그래밍 언어이자 컴파일러 언어이다(그 전에는 PHP와 Javascript를 사용했다).
 
인터넷에 '자바의 단점'을 검색해 보면 다양한 항목을 찾을 수 있다. JVM에 의한 실행 속도 문제, 함수형 프로그래밍 관점의 접근이 어렵다는 문제, 소스코드 작성 시 보일러플레이트가 상대적으로 많이 발생한다는 문제 등... 이 중 한 가지를 꼽아야 한다면 가능한 내가 직접 겪은 불편함을 꼽고 싶은데, 자바의 장점이자 동시에 단점이기도 한 `복잡성`이다.


 
객체지향 프로그래밍은 태생부터 복잡할 수밖에 없다. 대규모의 코드를 효율적으로 관리하기 위해 등장한 것이므로 당연하다. 객체란 효율성을 위해 극도로 추상화되어 있으며, 개념만 표현할 뿐 동작을 표현하지 않는다. 객체지향 프로그래밍은 이러한 특성을 통해 수많은 장점을 얻었지만 그럼에도 불편함과 어려움도 있었다. 이 '복잡함'은 자바의 장점인 동시에 단점인 셈이다.
 
`객체지향`은 그 단어 하나만으로 책 한 권도 쓸 수 있는 깊은 주제이므로, 이에 대해 정확한 설명과 비판을 이 문서에 모두 적을 수는 없다. 다만 그에 대한 개략적 개념은 이해하고 있다는 전제 하에 구체적 예시를 들면서 설명하고 싶다.
 
---
 
`n`회만큼 6면체 주사위 두 개를 굴리고, 각 횟수마다 나온 값을 더해 배열에 저장하고 출력하는 프로그램의 코드는 각각 다음과 같다.

```
// Javascript:

let arr = [];
let n = inputId.value;

for (i = 0; i < n; i ++) {
    arr[i] = Math.floor(Math.random() * 6) + 1;
}

console.log(arr);
```

```
// Java:

package example.pre.onbording;

import java.util.Scanner;
import java.util.Arrays;
import java.util.Math;

public class Example1() {
    public static void main() {
        Scanner sc = new Scanner(System.in);
        int input = sc.nextInt();
        int[] arr = new int[n];

        for (int i = 0; i < n; i ++) {
            arr[i] = (int)(Math.random() * 6 + 1);
        }

        System.out.println(Array.toString(arr));
    }
}
```

한 눈에 보더라도 `Javascript(이하 js)`의 코드가 훨씬 간결하며 직관적이다. 두 언어가 사용되는 환경과 목적이 완전히 다르긴 하지만, 대규모 프로그램을 작성할 때 안정적 구조를 보장한다는 자바의 장점이 반대로 간단한 프로그래밍 시에는 걸림돌이 되는 것을 알 수 있다.
 
한 가지 상황을 추가로 더 생각해 보자. 해당 코드가 실행된 이후 배열의 길이를 `n2`만큼 증가시켜야 한다면 어떻게 해야 할까.
 
 
```
// Javascript:

let arr = [];
let n = inputId.value;

for (i = 0; i < n; i ++) {
    arr[i] = Math.floor(Math.random() * 6) + 1;
}

console.log(arr);

let n2 = inputId2.value;
for (i = n; i < n + n2; i ++) {
    arr[i] = Math.floor(Math.random() * 6) + 1;
}

console.log(arr);
```

```
// Java:

package example.pre.onbording;

import java.util.Scanner;
import java.util.Arrays;
import java.util.Math;

public class Example1() {
    public static void main() {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];

        for (int i = 0; i < n; i ++) {
            arr[i] = (int)(Math.random() * 6 + 1);
        }

        System.out.println(Arrays.toString(arr));

        int n2 = sc.nextInt();
        int[] arr2 = Arrays.copyOf(arr, n + n2);
        for (int i = n; i < n + n2; i ++) {
            arr[i] = (int)(Math.random() * 6 + 1);
        }

        System.out.println(Arrays.toString(arr))
    }
}
```

js와 달리 자바에서는 배열의 길이를 바꾸기 위해 아예 `새로운 배열을 선언`한 것을 볼 수 있다.
 
여기서 배열의 정확한 의미를 짚고 넘어가자면, `배열(Array)`은 자료 구조의 하나로, 메모리 상에서 각 요소들이 같은 크기의 공간을 차지하고 연속적으로 배치되어 있는 특성을 갖고 있다. 이 특성 덕분에 인덱스를 통해 각 요소에 바로 접근하는 것이 용이하지만, 예제처럼 요소를 추가하거나 삭제할 때에는 새 배열을 만들어야 하므로 번거롭다. 또 배열에 할당되는 메모리는 시작지점부터 배열의 크기만큼 연속적으로 계산되기 때문에 모든 배열의 크기는 초기화 때 반드시 정해져야 한다. 또 배열 내부에 포함되는 자료형은 모두 동일해야 하는데, 각 자료형의 크기와 배열의 요소 갯수를 곱해 배열의 크기를 유추할 수 있어야 하기 때문이다. 이를 `정적 배열`이라고 부르기도 한다.
 
사실 엄밀히 말하면 Javascript의 배열 쪽이 오히려 엄격한 의미에서의 배열이 아니고, 해시 방식을 이용해 간접적으로 구현된 배열(`동적 배열`이라고도 한다)이기 때문에 꼭 필요한 만큼의 메모리를 사용하는 정적 배열에 비해 메모리 낭비가 커질 우려가 있다. 그러나 현대에 이르러 소프트웨어의 공간적 제약(메모리)이 많이 완화되었기에 개발자가 실제 프로그래밍을 할 때 더 쉽고 간편한 동적 배열 쪽의 코드가 더 효율적일 수 있다.
 
물론 자바에서도 이런 편의성 문제를 해결하기 위한 `Collection 프레임워크`를 제공한다. 다만 이 Collection 프레임워크를 사용하고 있다 보면 자바의 또 다른 불편함 한 가지를 느낄 수 있다. 바로 `모든 메서드는 반드시 객체에 속해 있어야 한다`는 점이다.

---
 
자바에서는 모든 것이 `객체`를 기준으로 돌아간다. 메서드 역시 객체에 속한 멤버로 취급되며, 다른 언어에서의 sort(), input() 등 간결히 사용할 수 있는 내장 함수가 존재하지 않는다. 예제 코드에서도 알 수 있듯 파이썬의 input()이나 php의 sort() 역할을 하는 메서드를 사용하기 위해서는 Scanner나 Arrays 등 해당 메서드를 포함한 클래스를 명시하고 그 클래스에서 호출해내는 형태로만 메서드를 사용할 수 있다.
 
언어를 막 배우기 시작한 초반에는 이를 단순히 코드량이 많아 불편하다, 외워야 할 클래스가 많아 어렵다 정도로만 이해하였다가, 자바의 `람다식`을 접한 후로 생각이 많이 달라졌다. 람다를 통해 `함수` 그 자체를 매개로 넘기는 방식의 프로그래밍을 접하고, 이것이 객체지향 프로그래밍 특유의 복잡성과 추상성을 상쇄하는 간결하고 직관적인 문법이라고 느꼈다. 자바 프로그램을 짤 때 객체지향 원칙을 엄격히 적용하다 보면 실용적이지 않은 부분이 반드시 생기게 되는데, 람다나 함수형 인터페이스들이 그런 부분을 어느 정도 해소해 주는 기분이었다.
 
그러나 가장 처음에 서술했듯, 이 '복잡성'은 자바의 단점이면서 동시에 장점이기도 하다. 따라서 설계적 `결함`이라고 부르기에는 다소 어려움이 있을지도 모르겠다. 하지만 이것이 설계로부터 비롯된 단점이기도 함은 분명하다. 이 단점을 상쇄하기 위해 자바 역시 수많은 개선을 해 왔고, 이 글에서 지적한 부분들에 대해서도 완전하지는 않으나 나름대로 충분한 보완책을 갖추었다고 생각한다. 또 자바의 단점을 상쇄한 `Scala`나 `Kotlin` 등의 대안도 존재하므로 이 단점을 상쇄하기 위한 개발자의 선택지는 다양하다고 하겠다.
